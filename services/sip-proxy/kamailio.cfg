#!KAMAILIO

#!define MULTIDOMAIN 0

# - flags
#   FLT_ - per transaction (message) flags
#	FLB_ - per branch flags
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
debug=2
log_stderror=no

memdbg=5
memlog=5

log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

/* number of SIP routing processes */
children=2

/* uncomment the next line to disable TCP (default on) */
# disable_tcp=yes

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
# auto_aliases=no

/* add local domain aliases */
# alias="sip.mydomain.com"

/* listen addresses */
# listen=udp:127.0.0.1:5060

####### Custom Parameters #########

/* These parameters can be modified runtime via RPC interface
 * - see the documentation of 'cfg_rpc' module.
 *
 * Format: group.id = value 'desc' description
 * Access: $sel(cfg_get.group.id) or @cfg_get.group.id */

####### Modules Section ########

/* set paths to location of modules */
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "counters.so"
loadmodule "uac.so"
loadmodule "db_mysql.so"
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "sqlops.so"
loadmodule "cfgutils.so";

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 30000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)
modparam("tm", "rich_redirect", 0)

modparam("rr", "enable_full_lr", 0)
modparam("rr", "append_fromtag", 1)

#!define DBURL "mysql://kamailio:@localhost/kamailio"
modparam("sqlops", "sqlcon", "ca=>mysql://kamailio:@localhost/kamailio")

modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "username")

modparam("uac","auth_username_avp","$avp(auser)")
modparam("uac","auth_password_avp","$avp(apass)")
modparam("uac","auth_realm_avp","$avp(arealm)")

####### Routing Logic ########

# Main message handler
request_route {
    # Simple filter to avoid bots.
    route(REQINIT);

    if (is_method("CANCEL")) {
        if (t_check_trans()) {
            route(RELAY);
        }
        exit;
    }

    # handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # We need to authenticate the incoming messages.
    # Calls the AUTH subroutine. 
    route(AUTH);
    # Allow in-dialog communication.
    # Such as re-invite, and more...
    route(WITHINDLG);

    # From now on we only have 
#	remove_hf("Route");
#	remove_hf("Via");

    # If our username in the request URN is empty, we deny the request.
    if ($rU==$null) {
        # request with no Username in RURI
        sl_send_reply("484", "Address Incomplete");
        exit;
    }

    # We recover the target user.
    $var(user) = $tU;

    # We check if the target user is indeed six digits long.
    if ($(var(user){s.len}) != 6) {
        sl_send_reply("484", "Invalid address -- Must be six digits");
        exit;
    }

    # We get the first three digits of the number
    # Since all numbers in the orion network start with the 
    # id of the target ipbx, we can simply assume it's the user id.
    $avp(user_ipbx_s) = $(var(user){s.substr,0,3});
    $var(user_ipbx) = $(var(user){s.substr,0,3}{s.int});

    if ($var(user_ipbx) < 1 && $var(user_ipbx) > 255) {
        sl_send_reply("484", "Invalid address -- No valid prefix");
        exit;
    }
    # We change the target domain to the target ipbx
    $td = "10.30.0.3";
    # We change the target uri to the target ipbx ip.
    $fd = "10.30.0.3";
    $du = "sip:" + "10.30." + $var(user_ipbx) + ".255" + ":5090";

    # We finally relay the messages.
    route(RELAY);
    exit;
}

route[AUTH] {
    # Save the original user
    $var(original_user) = $fU;

    # Update the from header before auth because we ignore the three last digits.
    $fU = $(fU{s.substr,0,3});
    # Apply the changes to the message
    msg_apply_changes();

    # We construct the domain from the first three digits.
    $var(source_prefix) = $(fU{s.substr,0,3}{s.int});

    $var(source_domain) = "10.30.0.3";


    # We check if the auth is present in the message using the source domain.
    if (!auth_check("$var(source_domain)", "subscriber", "1")) {
        # If not, we ask or a auth challenge.
        auth_challenge("$var(source_domain)", "1");
        exit;
    }

    consume_credentials(); # Remove the credentials from the request

    # Restore the original from user
    $fU = $var(original_user);
    msg_apply_changes();
}


# Wrapper for relaying requests
route[RELAY] {
    append_hf("X-Proxy: Proxied by Kamailio (Orion)\r\n");

    # enable additional event routes for forwarded requests
    # - serial forking, RTP relaying handling, a.s.o.

    if (is_method("MESSAGE|INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay()) {
        sl_reply_error();
    }

    exit;
}

# Per SIP request initial checks
route[REQINIT] {
    # Silently drop scanners.
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
        exit;
    }
    # Avoid routing loops.
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483", "Too Many Hops");
        exit;
    }
    # Accept keepalive requests
    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200", "Keepalive");
        exit;
    }
    # Malformed sip message.
    if(!sanity_check("1511", "7")) {
        xlog("Malformed SIP message from $si:$sp\n");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    # sequential request within a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        if ( is_method("NOTIFY") ) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
        exit;
    }

    if ( is_method("ACK") ) {
        if ( t_check_trans() ) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            exit;
        }
    }
    
    sl_send_reply("404", "Not here");
    exit;
}

# Manage incoming replies
onreply_route {
    append_hf("X-Proxy: Proxied by Kamailio (Orion)\r\n");
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
    xerr("FAILURE ROUTE!");

    if (t_is_canceled()) exit;

    # If we failed to send the message to the target ipbx
    # We get the password from the database and re-send the message.
    if(t_check_status("401|407")) {
        # Fetch database
        if (sql_xquery("ca",  "select password from subscriber where username=$avp(s:user_ipbx_s)", "ra") == 1) {
            # Update the password, user and 
            $avp(auser) = $avp(s:user_ipbx_s);
            $avp(apass) = $xavp(ra=>password);
            $avp(arealm) = "10.30.0.3";
            # Add auth headers.
            uac_auth();
            # Relay the message
            t_relay();

            exit;
        }
    }
    exit;
}
