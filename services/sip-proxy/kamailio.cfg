#!KAMAILIO

#!define MULTIDOMAIN 0

# - flags
#   FLT_ - per transaction (message) flags
#	FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
debug=2
log_stderror=no

memdbg=5
memlog=5

log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

/* number of SIP routing processes */
children=2

/* uncomment the next line to disable TCP (default on) */
# disable_tcp=yes

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
# auto_aliases=no

/* add local domain aliases */
# alias="sip.mydomain.com"

/* listen addresses */
# listen=udp:127.0.0.1:5060

####### Custom Parameters #########

/* These parameters can be modified runtime via RPC interface
 * - see the documentation of 'cfg_rpc' module.
 *
 * Format: group.id = value 'desc' description
 * Access: $sel(cfg_get.group.id) or @cfg_get.group.id */

####### Modules Section ########

/* set paths to location of modules */
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "textops.so"
loadmodule "textopsx.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
loadmodule "uac.so"
loadmodule "db_mysql.so"
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "sqlops.so"

# ----------------- setting module-specific parameters ---------------


# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
# modparam("jsonrpcs", "fifo_name", "/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
# modparam("jsonrpcs", "dgram_socket", "/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
/* set the path to RPC unix socket control file */
# modparam("ctl", "binrpc", "unix:/run/kamailio/kamailio_ctl")

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 30000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)

# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 0)
# do not append from tag to the RR (no need for this script)
# modparam("rr", "append_fromtag", 0)

# ----- acc params -----
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
/* by default ww do not adjust the direct of the sequential requests.
 * if you enable this parameter, be sure the enable "append_fromtag"
 * in "rr" module */
modparam("acc", "detect_direction", 0)
/* account triggers (flags) */
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra",
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)

#!define DBURL "mysql://kamailio:kamailio@localhost/kamailio"

modparam("sqlops", "sqlcon", "ca=>mysql://kamailio:kamailio@localhost/kamailio")

modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "username")

modparam("uac","auth_username_avp","$avp(auser)")
modparam("uac","auth_password_avp","$avp(apass)")
modparam("uac","auth_realm_avp","$avp(arealm)")

####### Routing Logic ########

# Main message handler
request_route {
	# Simple filter to avoid bots.
	route(REQINIT);

	if (is_method("CANCEL")) {
		if (t_check_trans()) {
			route(RELAY);
		}
		exit;
	}

	# handle retransmissions
	if (!is_method("ACK")) {
		if(t_precheck_trans()) {
			t_check_trans();
			exit;
		}
		t_check_trans();
	}

    # We need to authenticate the incoming messages.
    # Calls the AUTH subroutine. 
	route(AUTH);
	# Allow in-dialog communication.
    # Such as re-invite, and more...
	route(WITHINDLG);

    # From now on we only have 
	remove_hf("Route");

	# account only INVITEs
	if (is_method("INVITE")) {
		setflag(FLT_ACC); # do accounting
	}

    # If our username in the request URN is empty, we deny the request.
	if ($rU==$null) {
		# request with no Username in RURI
		sl_send_reply("484", "Address Incomplete");
		exit;
	}

    # We recover the target user.
    $var(user) = $tU;

    # We check if the target user is indeed six digits long.
    if ($(var(user){s.len}) != 6) {
        sl_send_reply("484", "Invalid address -- Must be six digits");
        exit;
    }

    # We get the first three digits of the number
    # Since all numbers in the orion network start with the 
    # id of the target ipbx, we can simply assume it's the user id.
	$avp(user_ipbx_s) = $(var(user){s.substr,0,3});
    $var(user_ipbx) = $(var(user){s.substr,0,3}{s.int});

    if ($var(user_ipbx) > 0 && $var(user_ipbx) < 256) {
        sl_send_reply("484", "Invalid address -- Mise be a valid prefix");
        exit;
    }
    # We change the target domain to the target ipbx
	$td = "10.30." + $var(user_ipbx) + ".255";
    # We change the target uri to the target ipbx ip.
    $du = "sip:" + "10.30." + $var(user_ipbx) + ".255" + ":5090";

    # We finally relay the messages.
	route(RELAY);
	exit;
}

route[AUTH] {
    # Save the original user
    $var(original_user) = $fU;

    # Update the from header before auth because we ignore the three last digits.
    $fU = $(fU{s.substr,0,3});
    # Apply the changes to the message
    msg_apply_changes();

    # We construct the domain from the first three digits.
    $var(source_prefix) = $(fU{s.substr,0,3}{s.int});
	$var(source_domain) = "10.30." + $var(prefix) + ".255";

    # We check if the auth is present in the message using the source domain.
    if (!auth_check("$var(source_domain)", "subscriber", "1")) {
        # If not, we ask or a auth challenge.
        auth_challenge("$var(source_domain)", "1");
        exit;
    }

    consume_credentials(); # Remove the credentials from the request

    # Restore the original from user
    $fU = $var(original_user);
    msg_apply_changes();
}


# Wrapper for relaying requests
route[RELAY] {
    append_hf("X-Proxy: Proxied by Kamailio (Orion)\r\n");

	# enable additional event routes for forwarded requests
	# - serial forking, RTP relaying handling, a.s.o.

	if (is_method("INVITE")) {
		if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}

	if (!t_relay()) {
		sl_reply_error();
	}

	exit;
}

# Per SIP request initial checks
route[REQINIT] {
    # Silently drop scanners.
	if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
		exit;
	}
    # Avoid routing loops.
	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483", "Too Many Hops");
		exit;
	}
    # Accept keepalive requests
	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
		sl_send_reply("200", "Keepalive");
		exit;
	}
    # Malformed sip message.
	if(!sanity_check("1511", "7")) {
		xlog("Malformed SIP message from $si:$sp\n");
		exit;
	}
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
	if (!has_totag()) return;

	# sequential request within a dialog should
	# take the path determined by record-routing
	if (loose_route()) {
		if (is_method("BYE")) {
			setflag(FLT_ACC); # do accounting ...
			setflag(FLT_ACCFAILED); # ... even if the transaction fails
		} else if ( is_method("NOTIFY") ) {
			# Add Record-Route for in-dialog NOTIFY as per RFC 6665.
			record_route();
		}
		route(RELAY);
		exit;
	}

	if ( is_method("ACK") ) {
		if ( t_check_trans() ) {
			# no loose-route, but stateful ACK;
			# must be an ACK after a 487
			# or e.g. 404 from upstream server
			route(RELAY);
			exit;
		} else {
			# ACK without matching transaction ... ignore and discard
			exit;
		}
	}
    
	sl_send_reply("404", "Not here");
	exit;
}

# Manage incoming replies
onreply_route {
	append_hf("X-Proxy: Proxied by Kamailio (Orion)\r\n");
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
	if (t_is_canceled()) exit;

    # If we failed to send the message to the target ipbx
    # We get the password from the database and re-send the message.
    if(t_check_status("401|407")) {
		# Fetch database
		if (sql_xquery("ca",  "select password from subscriber where username=$avp(s:to_user)", "ra") == 1) {
            # Update the password, user and 
        	$avp(auser) = $avp(s:user_ipbx_s);
	        $avp(apass) = $xavp(ra=>password);
       	    $avp(arealm) = $(du{uri.host});
            # Add auth headers.
            uac_auth();
            # Relay the message
            t_relay();

			exit;
		}
    }
    exit;
}
